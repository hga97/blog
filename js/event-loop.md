### 前言

**js 从诞生起就是一门单线程的非阻塞的脚本语言。**

#### 单线程

js 代码在执行的时候，都只有一个主线程来处理所有的任务。

#### 非阻塞

当代码需要进行一项异步任务的时候，主线程会挂起这个任务，
然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。

#### 为啥是单线程

单线程是必要的，是 js 语言的基石，原因 js 的执行环境————**浏览器**。

浏览器中，我们需要进行各种各样的 dom 操作，如果 js 是多线程的，那么当两个线程同时对 dom 进行操作，
一个添加事件，另一个删除这个 dom。此时该如何处理呢？为了保证不会发生类似场景，js 选择只用一个主线程来执行代码，保证程序执行的一致性。

#### “多线程”

单线程在保证了执行顺序的同时也限制了 js 的执行效率，进而开发了 web worker 技术。

?>web worder  
web worker 技术开的多线程有着诸多限制：  
1、所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程”
实际上应属于主线程的子线程。  
2、这些子线程并没有执行 I/O 操作的权限，只能为主线程分担一些诸如计算等任务。  
所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了 js 语言的单线程本质。

#### event loop

**js 是单线程，但单线程就导致有很多任务需要排队，只有一个任务执行完才能执行后一个任务。如果某个执行时间太长，就容易造成阻塞。为了解决这一个问题，js 引入了事件循环机制。**

### 浏览器环境下 js 引擎的 event loop

#### 执行栈与事件队列

1、堆和栈

js 执行代码会将不同的变量存于内存中的不同位置，堆里存放一些对象，栈中则存放一些基础类型变量以及对象的指针。

?> 堆和栈  
1、栈空间就是调用栈，是用来存储执行上下文的。(call statck)  
2、对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 js 需要访问该数据的时候，是通过栈中的引用地址来访问的。  
3、栈空间都不会设置太大，主要用来存放一些原始类型的小数据。引用类型的数据占用的空间比较大，这一类数据会被存放到堆中，堆空间很大。能存放很多大的数据。

2、执行栈（调用栈）

**执行上下文**

调用一个方法时，js 会生成对应的执行环境，又叫执行上下文。

**变量对象+作用域+this**

这个执行环境中存在这个方法的私有作用域、上层作用域的指向、参数、这个作用域中定义的变量、
这个作用域的 this 对象，即变量对象+作用域+this。

**执行栈**

当一系列方法被依次调用的时候，因为 js 是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。
这个地方被称为执行栈。

**执行过程**

当一个脚本第一次执行的时候，js 引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。
如果当前执行的是一个方法，那么 js 会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。
当这个执行环境中的代码执行完毕并返回结果后，js 会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。
这个过程反复进行，直到执行栈中的代码全部执行完毕。(**后进先出**)

一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。

以上的过程说的都是同步代码的执行。

3、事件队列

js 引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js 会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。

被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。(**先进先出**)

#### 微任务和宏任务

1、宏任务

- setInterval
- setTimeout

2、微任务

- Promise.then/cath /finally 回调
- new MutaionObserver()

在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被放在对应的宏任务队列或者微任务队列中去。
并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回调加入当前执行栈；
如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。

**当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。**

#### 面试题

```javascript
function start() {
  calc();
  console.log("start");
}

function ctimer1() {
  calc();
  console.log("ctimer1");
}

function ctimer2() {
  calc();
  console.log("ctimer2");
}

function promise1() {
  calc();
  console.log("promise1");
}

function promise2() {
  calc();
  console.log("promise2");
}

function calc(b = 100000000) {
  let a = 0;
  for (let i = 0; i < b; i++) {
    a += i;
  }
}

Promise.resolve().then(() => {
  promise1();

  const timer2 = setTimeout(() => {
    ctimer2();
  }, 0);
});

const timer1 = setTimeout(() => {
  ctimer1();

  Promise.resolve().then(() => {
    promise2();
  });
}, 0);

start();
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/cd84694a0a254be997c30d4ce496966e.png)

红框：宏任务  
绿框：微任务

第一个宏任务

- 同步执行，遇到 Promise.resolve().then 放到微任务队列，遇到定时器 1 放到宏任务队列。遇到 start，打印"start"。
- 调用栈执行完毕，处理微任务队列，将 Promise.resolve().then 的回调放入执行栈。同步执行，遇到 promise1，打印"promise1"。遇到定时器 2 放到宏任务队列。

第二个宏任务

- 微任务执行完毕，处理宏任务队列，取出排在第一位的事件（定时器 1）回调放入执行栈。同步执行，遇到 ctimer1，打印"ctimer1"。遇到 Promise.resolve().then 放到微任务。
- 调用栈执行完毕，处理微任务队列，将 Promise.resolve().then 的回调放入执行栈。同步执行，遇到 promise2，打印"promise2"。

第三个宏任务

- 微任务执行完毕，处理宏任务队列，取出排在第一位的事件（定时器 2）回调放入执行栈。同步执行，遇到 ctimer2，打印"ctimer2"。
- 调用栈执行完毕，没有微任务和宏任务了，事件循环结束。
